#常见算法

##分治算法

###相关文章

* [分治算法](http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html)
* [算法系列总结：分而治之——分治算法](http://www.cnblogs.com/Creator/archive/2011/06/18/2084267.html)
* [Merge Sort](http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/mergeSort.htm)

###概念
```
把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并
```

###例子

####归并排序

#####伪代码

```
MERGE-SORT(A,p,r)
    IF p < r
        THEN q = [(p + r) / 2]  //问题分解
        MERGE-SORT(A,p,q)       //继续递归直至子问题足够小
        MERGE-SORT(A,q+1,r)     //继续递归直至子问题足够小
        MERGE(A,p,q,r)          //合并解
```

#####算法时间复杂度
分解问题的时间复杂度为O(logn),合并解的时间复杂度为O(n),整个算法的时间复杂度为O(nlogn)

##回溯法

##贪心算法

##动态规划

##分支限界法

#数据结构
...

#排序算法
###冒泡排序
假设要求的数组是正序，两两进行比较，如果前一个数比后一个数小，位置不变。
如果前一个数比后一个数大，位置互换，再跟后一个数进行比较，直到最后。第一轮比较产出一个
最大数，同时将第二轮比较的范围缩小1位，以此类推，每一轮参与比较的数据组都会产出一个“最大数”，如同冒泡一般。
####伪代码
```
BUBBLESORT(A){
   for i = 1 to length[A]{
       for j = length[A] downto i+1{
           if A[j] < A[j-1]{
                exchange A[j] and A[j-1];
           }
       }
   }
}
```
###插入排序
插入排序就是每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。 
扑克的排序是这个算法的形象比喻：桌面上一叠未排序的扑克牌，左手拿的牌代表已排序的扑克，右手拿的表示待排序的
扑克牌，刚开始时左手牌为空（相当于已排序），抽一张牌给左手（依旧相当于已排序），从抽第二张牌开始，右手的牌
要插入左手的牌就需要与左手已经排好序的牌进行比较并插入到正确的位置。
####伪代码
```
INSERTION-SORT(A){
    for i = 2 to A.length {
        j = i - 1
        key = A[i]
        while j > 0 and key < A[j]{
            A[j + 1] = A[j]
            j = j- 1
        }
        A[j + 1] = key
    }
}
```